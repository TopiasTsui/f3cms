<?php
namespace F3CMS;

/**
 * Filecache handler
 */
class FCHelper extends Reaction
{
    /**
     * constructor
     *
     * @param  object $dbInstance - db instance
     * @return none
     */
    public function __construct()
    {
    }

    /**
     * @param  $filename
     * @param  $html
     * @return mixed
     */
    public function save($filename, $html = '')
    {
        return $filename;
    }

    /**
     * @param $arg
     */
    public function do_get($f3, $args)
    {
        $pass = '';
        extract(parent::_escape(f3()->get('POST')), EXTR_SKIP);

        switch ($name) {
            default:
                $this->action = 'about';
                break;
        }

        $html = $this->get($this->action, 7200);

        return parent::_return(1, array('html' => $html));
    }

    /**
     * @param $cacheName
     * @param $useWildcard
     */
    public function flush($cacheName, $useWildcard)
    {
        if ($useWildcard) {
            $this->removeFiles('cache.' . $cacheName . '*.html');
        } else {
            $this->removeFiles('cache.' . $cacheName . '.html');
        }
    }

    public function flushAll()
    {
        $this->removeFiles('cache.*.html');
    }

    /**
     * @param  $cacheName
     * @param  $maxLifetime
     * @return mixed
     */
    public function get($cacheName, $maxLifetime)
    {
        $filename = $this->getFilename($cacheName);

        if ($this->needRebuild($filename, $maxLifetime)) {
            return $this->requestSet($cacheName);
        }

        // load cache
        try {
            return $this->readCache($cacheName, $filename);
        } catch (\Exception $e) {
            return null;
        }
    }

    public function requestSet($cacheName)
    {
        $curl = curl_init();

        curl_setopt_array($curl, array(
            CURLOPT_URL            => f3()->get('uri') .'/'. $this->action,
            CURLOPT_SSL_VERIFYPEER => false,
            CURLOPT_SSL_VERIFYHOST => false,
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_ENCODING => "",
            CURLOPT_MAXREDIRS => 10,
            CURLOPT_TIMEOUT => 30,
            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
            CURLOPT_CUSTOMREQUEST => "GET",
            CURLOPT_HTTPHEADER     => array(
                'cache-control: no-cache'
            )
        ));

        $response = curl_exec($curl);
        $err = curl_error($curl);

        curl_close($curl);

        if ($err) {
            return 'cURL Error #:' . $err;
        } else {
            return $this->set($this->action, $response, 60);
        }
    }

    /**
     * @param $cacheName
     * @param $content
     * @param $maxLifetime
     */
    public function set($cacheName, $content, $maxLifetime)
    {
        $filename = $this->getFilename($cacheName);
        $content = '<!-- cache: ' . $cacheName . ' (generated at ' . date('y-m-d H:i:s') . ') DO NOT EDIT THIS FILE -->'
        . PHP_EOL . self::minify($content) . PHP_EOL . PHP_EOL;

        if (!file_exists($filename)) {
            mkdir(f3()->get('abspath') . 'tmp/cache/'. $this->action, 0770, true);
            touch($filename);
        }

        $handler = fOpen($filename, 'w+');
        fWrite($handler, $content);
        fClose($handler);

        return $content;
    }

    /**
     * Returns cache filename.
     *
     * @param  string   $cacheName
     * @return string
     */
    protected function getFilename($cacheName)
    {
        return f3()->get('abspath') . 'tmp/cache/'. $this->action .'/cache.' . $cacheName . '.html';
    }

    /**
     * Removes files matching given pattern.
     *
     * @param string $pattern
     */
    protected function removeFiles($pattern)
    {
        $directory = f3()->get('abspath') . 'tmp/cache/'. $this->action .'/';

        foreach (glob($directory . $pattern) as $filename) {
            @unlink($filename);
        }
    }

    /**
     * Determines wheater the cache needs to be rebuild or not.
     *
     * @param  string    $filename
     * @param  integer   $maxLifetime
     * @return boolean
     */
    protected function needRebuild($filename, $maxLifetime)
    {
        // cache does not exist
        if (!file_exists($filename)) {
            return true;
        }

        // cache is empty
        if (!@filesize($filename)) {
            return true;
        }

        // cache resource was marked as obsolete
        if (($mtime = filemtime($filename)) <= 1) {
            return true;
        }

        // maxlifetime expired
        if ($maxLifetime > 0 && (time() - $mtime) > $maxLifetime) {
            return true;
        }

        // do not rebuild cache
        return false;
    }

    /**
     * Loads the file of a cached resource.
     *
     * @param  string  $cacheName
     * @param  string  $filename
     * @return mixed
     */
    protected function readCache($cacheName, $filename)
    {
        // get file contents
        $content = file_get_contents($filename);

        // find first newline
        $position = strpos($content, "\n");
        if ($position === false) {
            throw new \Exception("Unable to load cache resource '" . $cacheName . "'");
        }

        // cut contents
        // $contents = substr($contents, $position + 1);

        return $content;
    }

    /**
     * @param $buffer
     * @return mixed
     */
    public static function minify($buffer)
    {
        //return $buffer;

        $search = array(
            '/\>[^\S ]+/s', // strip whitespaces after tags, except space
            '/[^\S ]+\</s', // strip whitespaces before tags, except space
            '/(\s)+/s' // shorten multiple whitespace sequences
        );

        $replace = array(
            '>',
            '<',
            '\\1'
        );

        $buffer = preg_replace($search, $replace, $buffer);

        return $buffer;
    }
}
